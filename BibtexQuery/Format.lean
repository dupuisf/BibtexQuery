/-
Copyright (c) 2024 Jz Pan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jz Pan
-/

import BibtexQuery.Name
import BibtexQuery.Entry
import Lean.Data.Xml.Basic
import Lean.Data.HashMap
import Std.Internal.Parsec
import Std.Internal.Parsec.String

/-!

# Bibtex item formatting

This file contains functions for bibtex item formatting,
tag generating and sorting.

-/

open Lean Xml Std.Internal.Parsec Unicode BibtexQuery.TexDiacritics BibtexQuery.Name

namespace BibtexQuery

/-- Represents a processed bibtex entry. -/
structure ProcessedEntry where
  /-- The category of a bibtex entry, e.g. "article" or "book". -/
  category : String
  /-- The name, or called citekey, of a bibtex entry. -/
  name : String
  /-- The tags of a bibtex entry, stored as a `HashMap`. Don't be confused with `tag`. -/
  tags : Std.HashMap String (Array TexContent)
  /-- The tag of a bibtex entry, e.g. `[Doe12]`. Don't be confused with `tags`. -/
  tag : String
  /-- The HTML representing a bibtex entry, e.g.
  `John Doe. <i>Test</i>. 2012.` Generated by bibtex formatter. -/
  html : Array Content
  /-- The array of authors or editors of a bibtex entry.
  Only used for tag generation and bibtex entry sorting. -/
  authorOrEditor : Array BibtexName
  /-- The HTML representing the authors. -/
  authorHtml : Array Content
  /-- The HTML representing the editors. -/
  editorHtml : Array Content
  /-- The date of a bibtex entry, in the format `year * 100 + month`.
  Only used for tag generation and bibtex entry sorting. -/
  date : Nat
  /-- The HTML representing the date. -/
  dateHtml : Array Content
  /-- The title of a bibtex entry, with diacritics removed, and converted to uppercase.
  Only used for bibtex entry sorting. -/
  titleWithoutDiacritics : String

/-- Get the date (which is `year * 100 + month`) and the date HTML of a bibitem. -/
def getDate (tags : Std.HashMap String (Array TexContent)) : Nat × Array Content :=
  if let .some yearTex := tags["year"]? then
    let yearHtml := TexContent.toHtmlArray yearTex
    if let .some year := (TexContent.toPlaintextArray yearTex).toList.filter
        Char.isDigit |> String.mk |>.toNat? then
      let month : Nat :=
        if let .some monthTex := tags["month"]? then
          let monthStr := (TexContent.toPlaintextArray monthTex).trim.toLower
          match monthStr with
          | "jan" => 1 | "feb" => 2 | "mar" => 3
          | "apr" => 4 | "may" => 5 | "jun" => 6
          | "jul" => 7 | "aug" => 8 | "sep" => 9
          | "oct" => 10 | "nov" => 11 | "dec" => 12
          | _ =>
            let month := monthStr.toNat?.getD 0
            if month ≥ 1 ∧ month ≤ 12 then month else 0
        else
          0
      let monthStr : String :=
        match month with
        | 1 => "Jan" | 2 => "Feb" | 3 => "Mar"
        | 4 => "Apr" | 5 => "May" | 6 => "Jun"
        | 7 => "Jul" | 8 => "Aug" | 9 => "Sep"
        | 10 => "Oct" | 11 => "Nov" | 12 => "Dec"
        | _ => ""
      (year * 100 + month,
        if monthStr.isEmpty then
          yearHtml
        else if yearHtml.isEmpty then
          #[.Character monthStr]
        else
          #[.Character monthStr, .Character " "] ++ yearHtml)
    else
      (0, yearHtml)
  else
    (0, #[])

/-- Get the tag of a bibitem (e.g. `[ABC12]`) from authors and date. -/
def getTag (authors : Array BibtexName) (date : Nat) : String :=
  let authorString :=
    if authors.size ≥ 5 then
      (authors.toSubarray.take 3 |>.toArray.map (·.oneLetterAbbr) |>.toList |> String.join) ++ "+"
    else if authors.size ≥ 2 then
      authors.map (·.oneLetterAbbr) |>.toList |> String.join
    else
      authors.map (·.threeLetterAbbr) |>.toList |> String.join
  let dateString := if date > 0 then (toString (date / 100 + 100)).takeRight 2 else ""
  "[" ++ authorString ++ dateString ++ "]"

partial def removeDuplicatedSpacesAux (s : String) : String :=
  let s2 := s.replace "  " " "
  if s2.length < s.length then
    removeDuplicatedSpacesAux s2
  else
    s

def removeDuplicatedSpaces (s : String) : String :=
  s.replace "\r" " " |>.replace "\n" " " |>.replace "\t" " " |>.trim |> removeDuplicatedSpacesAux

/-- Get a `ProcessedEntry` from an `Entry`, computes all its field except for `html`.
If the input is not `BibtexQuery.Entry.normalType`, returns `Option.none`. -/
def ProcessedEntry.ofEntry (e : Entry) : Except String (Option ProcessedEntry) := do
  match e with
  | .normalType category name tags =>
    let lst : List (String × Array TexContent) ← tags.mapM fun x => do
      let s := removeDuplicatedSpaces x.content
      if x.name = "pubmed" ∨ x.name = "doi" ∨ x.name = "eprint" ∨ x.name.endsWith "url" then
        .ok (x.name, #[.normal s])
      else
        match texContents s.iter with
        | .success _ arr => .ok (x.name, arr)
        | .error it err => .error s!"failed to run texContents on '{it.1}' at pos {it.2}: {err}"
    let tags := Std.HashMap.ofList lst
    let authors := processNames (tags.getD "author" #[])
    let editors := processNames (tags.getD "editor" #[])
    let authorOrEditor := if authors.isEmpty then editors else authors
    let (date, dateHtml) := getDate tags
    pure <| .some {
      category := category
      name := name
      tags := tags
      tag := getTag authorOrEditor date
      html := #[]
      authorOrEditor := authorOrEditor
      authorHtml := BibtexName.toHtmlArray authors
      editorHtml := BibtexName.toHtmlArray editors ++
        if editors.size ≥ 2 then
          #[.Character ", editors"]
        else if editors.size = 1 then
          #[.Character ", editor"]
        else
          #[]
      date := date
      dateHtml := dateHtml
      titleWithoutDiacritics := tags.getD "title" #[] |> TexContent.toPlaintextArray |>
        stripDiacriticsFromString |>.map getUpperChar
    }
  | _ => pure .none

/-!

## Formatting a bibtex item

The following code is a port of `pybtex/style/formatting/unsrt.py` of `pybtex`,
originally licensed under MIT license.

-/

section

mutual

partial def getLastCharOfContent (x : Content) : Option Char :=
  match x with
  | .Element ⟨ _, _, arr ⟩ => getLastCharOfArrayContent arr
  | .Comment _ => .none
  | .Character s => if s.isEmpty then .none else .some s.back

partial def getLastCharOfArrayContent (arr : Array Content) : Option Char :=
  arr.findSomeRev? getLastCharOfContent

end

variable (e : ProcessedEntry)

namespace Formatter

/-!

### Helper functions

-/

def mkTag (name : String) (content : Array TexContent) : Array Content :=
  let ret := TexContent.toHtmlArray content
  if ret.isEmpty then #[] else #[.Element ⟨ name, RBMap.empty, ret ⟩]

def mkHref (href : String) (content : Array TexContent) : Array Content :=
  let ret := TexContent.toHtmlArray content
  if ret.isEmpty then #[] else #[.Element ⟨ "a", RBMap.empty.insert "href" href, ret ⟩]

def mkStr (content : Array TexContent) (pre post : String := "") : Array Content :=
  let ret := TexContent.toHtmlArray content
  (if ret.isEmpty || pre.isEmpty then #[] else #[.Character pre]) ++ ret ++
    (if ret.isEmpty || post.isEmpty then #[] else #[.Character post])

def arrayConcat {α} (arr : Array (Option (Array α))) (sep : Array α := #[]) : Array α :=
  arr.filterMap id |>.foldl (fun acc a =>
    acc ++ (if acc.isEmpty || a.isEmpty then #[] else sep) ++ a) #[]

def words (arr : Array (Option (Array Content))) : Array Content :=
  arrayConcat arr #[.Character " "]

def canEndSentence (c : Char) : Bool :=
  match c with
  | '.' | '?' | '!' | '…' | '。' | '？' | '！' | '\uFF0E' | '\uFF61'
  | '\u203C' | '\u203D' | '\u2047' | '\u2048' | '\u2049' => true
  | _ => false

def sentence1 (arr : Array Content) : Array Content :=
  if arr.isEmpty then
    #[]
  else if canEndSentence (getLastCharOfArrayContent arr |>.getD ' ') then
    arr
  else
    arr ++ #[.Character "."]

def sentence (arr : Array (Option (Array Content))) : Array Content :=
  sentence1 <| arrayConcat arr #[.Character ", "]

def sentence' (content : Array TexContent) : Array Content :=
  sentence1 <| TexContent.toHtmlArray content

def toplevel (arr : Array (Option (Array Content))) : Array Content :=
  arrayConcat arr #[.Character "\n"]

def mkUrl (url : String) : Array Content :=
  if url.isEmpty then #[] else #[.Character "URL: "] ++ mkHref url #[.normal url]

def mkWebRef (urlPrefix namePrefix url : String) : Array Content :=
    let s :=
      if url.toLower.startsWith urlPrefix.toLower then
        url.drop urlPrefix.length
      else if url.toLower.startsWith namePrefix.toLower then
        url.drop namePrefix.length
      else
        url
    if s.toLower.startsWith "http" then
      -- the url does not starts with `urlPrefix` or `namePrefix`,
      -- but still starts with "http"
      mkUrl url
    else if s.isEmpty then
      #[]
    else
      mkHref (urlPrefix ++ s) #[.normal (namePrefix ++ s)]

/-!

### Partial templates

-/

def formatVolumeAndPages : Option (Array Content) := do
  let pages ← e.tags["pages"]?
  match e.tags["volume"]? with
  | .some volume =>
    arrayConcat #[
      mkStr volume,
      (mkStr · "(" ")") <$> e.tags["number"]?,
      mkStr pages ":"
    ]
  | .none => mkStr pages "pages "

def formatEprint : Option (Array Content) := do
  let eprint ← TexContent.toPlaintextArray <$> e.tags["eprint"]?
  let eprinttype :=
    TexContent.toPlaintextArray <$> (e.tags["eprinttype"]? <|> e.tags["archiveprefix"]?)
      |>.getD "arXiv"
  let eprintlist : Array (Array String × String × String) := #[
    (#["arxiv"], "https://arxiv.org/abs/", "arXiv:"),
    (#["iacr"], "https://eprint.iacr.org/", "IACR:"),
    (#["pmcid", "pmc"], "https://www.ncbi.nlm.nih.gov/pmc/articles/", "PMCID:")
  ]
  let checkEprint : Array String × String × String → Option (Array Content) :=
    fun (lst, urlPrefix, namePrefix) =>
      if lst.contains eprinttype.toLower then
        let ret := mkWebRef urlPrefix namePrefix eprint
        if ret.isEmpty then .none else .some ret
      else
        .none
  eprintlist.findSome? checkEprint <|> .some
    (if eprint.toLower.startsWith "http" then
      -- unrecognized eprint type but starts with "http"
      mkUrl eprint
    else
      -- unrecognized eprint type, cannot add link to it
      #[.Character (eprinttype ++ ":" ++ eprint)])

def formatWebRefs : Array Content :=
  let formatUrl : Option (Array Content) :=
    mkUrl <$> TexContent.toPlaintextArray <$> e.tags["url"]?
  let formatWebRef (tagName urlPrefix namePrefix : String) : Option (Array Content) :=
    mkWebRef urlPrefix namePrefix <$> TexContent.toPlaintextArray <$> e.tags[tagName]?
  sentence #[
    formatWebRef "pubmed" "https://www.ncbi.nlm.nih.gov/pubmed/" "PMID:",
    formatWebRef "doi" "https://doi.org/" "doi:",
    formatWebRef "mrnumber" "https://www.ams.org/mathscinet-getitem?mr=MR" "MR:",
    formatWebRef "zbl" "https://zbmath.org/?q=an:" "Zbl:",
    formatEprint e,
    formatUrl
  ]

def formatAuthorOrEditor : Array Content :=
  sentence1 (if e.authorHtml.isEmpty then e.editorHtml else e.authorHtml)

def formatVolumeAndSeries (asSentence : Bool) : Array Content :=
  let series := e.tags["series"]?
  let arr : Array Content :=
    if let .some volume := e.tags["volume"]? then
      arrayConcat #[
        mkStr volume (if asSentence then "Volume " else "volume "),
        (mkStr · " of ") <$> series
      ]
    else if let .some number := e.tags["number"]? then
      arrayConcat #[
        mkStr number (if asSentence then "Number " else "number "),
        (mkStr · " in ") <$> series
      ]
    else
      (mkStr <$> series).getD #[]
  if asSentence then sentence1 arr else arr

def formatChapterAndPages : Array Content :=
  arrayConcat #[
    (mkStr · "chapter ") <$> e.tags["chapter"]?,
    (mkStr · "pages ") <$> e.tags["pages"]?
  ] #[.Character ", "]

def formatEdition : Option (Array Content) :=
  if let .some arr := e.tags["edition"]? then
    let s := TexContent.toPlaintextArray arr |> stripDiacriticsFromString |>.map getLowerChar
    if s.endsWith " ed." || s.endsWith " ed" || (s.replace "edition" "").length < s.length then
      TexContent.toHtmlArray arr
    else if let .some n := s.toNat? then
      let s : String := match n with
      | 0 => "Zeroth" | 1 => "First" | 2 => "Second" | 3 => "Third"
      | 4 => "Fourth" | 5 => "Fifth" | 6 => "Sixth" | 7 => "Seventh"
      | 8 => "Eighth" | 9 => "Ninth" | 10 => "Tenth" | 11 => "Eleventh"
      | 12 => "Twelfth"
      | _ => toString n ++ match n % 100 with
        | 11 | 12 => "th"
        | _ => match n % 10 with
          | 1 => "st"
          | 2 => "nd"
          | 3 => "rd"
          | _ => "th"
      .some #[.Character (s ++ " edition")]
    else
      mkStr arr "" " edition"
  else
    .none

def formatAddressOrganizationPublisherDate (includeOrganization : Bool) :
    Array Content :=
  let organization : Option (Array Content) :=
    if includeOrganization then
      mkStr <$> e.tags["organization"]?
    else
      .none
  if let .some address := e.tags["address"]? then
    words #[
      sentence #[
        mkStr address,
        e.dateHtml
      ],
      sentence #[
        organization,
        mkStr <$> e.tags["publisher"]?
      ]
    ]
  else
    sentence #[
      organization,
      mkStr <$> e.tags["publisher"]?,
      e.dateHtml
    ]

def formatISBN : Option (Array Content) :=
  (sentence1 <| mkStr · "ISBN ") <$> e.tags["isbn"]?

/-!

### Templates

-/

def formatArticle : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    sentence #[
      mkTag "i" <$> e.tags["journal"]?,
      formatVolumeAndPages e,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatBook : Array Content :=
  toplevel #[
    formatAuthorOrEditor e,
    sentence #[mkTag "i" <$> e.tags["title"]?],
    sentence1 <$> formatEdition e,
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags["publisher"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    formatISBN e,
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatBooklet : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags["howpublished"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml,
      mkStr <$> e.tags["note"]?
    ],
    formatWebRefs e
  ]

def formatInBook : Array Content :=
  toplevel #[
    formatAuthorOrEditor e,
    sentence #[
      mkTag "i" <$> e.tags["title"]?,
      formatEdition e,
      formatChapterAndPages e
    ],
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags["publisher"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml,
      mkStr <$> e.tags["note"]?
    ],
    formatWebRefs e
  ]

def formatInCollection : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    (fun x => #[.Character "In "] ++ x) <$> sentence #[
      e.editorHtml,
      mkTag "i" <$> e.tags["booktitle"]?,
      formatEdition e,
      formatVolumeAndSeries e false,
      formatChapterAndPages e
    ],
    sentence #[
      mkStr <$> e.tags["publisher"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    formatWebRefs e
  ]

def formatInProceedings : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    (fun x => #[.Character "In "] ++ x) <$> words #[
      sentence #[
        e.editorHtml,
        mkTag "i" <$> e.tags["booktitle"]?,
        formatVolumeAndSeries e false,
        mkStr <$> e.tags["pages"]?
      ],
      formatAddressOrganizationPublisherDate e true
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatManual : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence #[mkTag "i" <$> e.tags["title"]?],
    sentence1 <$> formatEdition e,
    sentence #[
      mkStr <$> e.tags["organization"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatMasterThesis : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    sentence #[
      .some #[.Character "Master's thesis"],
      mkStr <$> e.tags["school"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatMisc : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    sentence #[
      mkStr <$> e.tags["howpublished"]?,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatPhDThesis : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence #[mkTag "i" <$> e.tags["title"]?],
    sentence #[
      (mkStr <$> e.tags["type"]?) <|> .some #[.Character "PhD thesis"],
      mkStr <$> e.tags["school"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatProceedings : Array Content :=
  let arr : Array (Option (Array Content)) :=
    if e.editorHtml.isEmpty then
      #[
        sentence' <$> e.tags["organization"]?,
        sentence #[
          mkTag "i" <$> e.tags["title"]?,
          formatVolumeAndSeries e false,
          formatAddressOrganizationPublisherDate e false
        ]
      ]
    else
      #[
        sentence1 e.editorHtml,
        sentence #[
          mkTag "i" <$> e.tags["title"]?,
          formatVolumeAndSeries e false,
          formatAddressOrganizationPublisherDate e true
        ]
      ]
  toplevel <| arr ++ #[
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatTechReport : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    sentence #[
      words #[
        (mkStr <$> e.tags["type"]?) <|> .some #[.Character "Technical Report"],
        mkStr <$> e.tags["number"]?
      ],
      mkStr <$> e.tags["institution"]?,
      mkStr <$> e.tags["address"]?,
      e.dateHtml
    ],
    sentence' <$> e.tags["note"]?,
    formatWebRefs e
  ]

def formatUnpublished : Array Content :=
  toplevel #[
    sentence1 e.authorHtml,
    sentence' <$> e.tags["title"]?,
    sentence #[
      mkStr <$> e.tags["note"]?,
      e.dateHtml
    ],
    formatWebRefs e
  ]

def format : Array Content :=
  match e.category with
  | "article" => formatArticle e
  | "book" => formatBook e
  | "booklet" => formatBooklet e
  | "inbook" => formatInBook e
  | "incollection" => formatInCollection e
  | "inproceedings" | "conference" => formatInProceedings e
  | "manual" => formatManual e
  | "mastersthesis" => formatMasterThesis e
  | "misc" | "online" => formatMisc e
  | "phdthesis" => formatPhDThesis e
  | "proceedings" => formatProceedings e
  | "techreport" => formatTechReport e
  | "unpublished" => formatUnpublished e
  | _ => #[.Character ("TODO: " ++ e.category)]

end Formatter

/-- Fill the `html` field of `ProcessedEntry`. -/
def ProcessedEntry.format : ProcessedEntry :=
  { e with html := Formatter.format e }

end

/-!

## Sorting bibtex items

-/

def compareAuthor (a b : BibtexName) : Ordering :=
  if a.lastNameWithoutDiacritics < b.lastNameWithoutDiacritics then
    .lt
  else if a.lastNameWithoutDiacritics > b.lastNameWithoutDiacritics then
    .gt
  else if a.firstNameWithoutDiacritics < b.firstNameWithoutDiacritics then
    .lt
  else if a.firstNameWithoutDiacritics > b.firstNameWithoutDiacritics then
    .gt
  else
    .eq

partial def compareAuthors (a b : Array BibtexName) (i : Nat := 0) : Ordering :=
  if ha : i < a.size then
    if hb : i < b.size then
      match compareAuthor a[i] b[i] with
      | .lt => .lt | .gt => .gt
      | .eq => compareAuthors a b (i + 1)
    else
      .gt
  else
    if i < b.size then .lt else .eq

def compareEntry (a b : ProcessedEntry) : Ordering :=
  match compareAuthors a.authorOrEditor b.authorOrEditor with
  | .lt => .lt | .gt => .gt
  | .eq =>
    if a.date < b.date then
      .lt
    else if a.date > b.date then
      .gt
    else if a.titleWithoutDiacritics < b.titleWithoutDiacritics then
      .lt
    else if a.titleWithoutDiacritics > b.titleWithoutDiacritics then
      .gt
    else
      .eq

/-- Sort an array of bibtex entries. -/
def sortEntry (arr : Array ProcessedEntry) : Array ProcessedEntry :=
  arr.qsort (compareEntry · · |>.isLT)

partial def toBase26Aux (n : Nat) (length : Nat) (s : String) : String :=
  if length = 0 then
    s
  else
    toBase26Aux (n / 26) (length - 1) <| toString (Char.ofNat (97 + n % 26)) ++ s

partial def toBase26 (n : Nat) (length : Nat := 1) : String :=
  if n ≥ 26 ^ length then
    toBase26 (n - 26 ^ length) (length + 1)
  else
    toBase26Aux n length ""

partial def deduplicateTagAux
    (x : Array String × Std.HashMap String (Nat × Nat)) (i : Nat) :
    Array String × Std.HashMap String (Nat × Nat) :=
  if h : i < x.1.size then
    let tag := x.1[i]
    let y : Array String × Std.HashMap String (Nat × Nat) :=
      if let .some (first, count) := x.2[tag]? then
        let z : Array String :=
          if count = 0 then
            x.1.modify first fun x => x.dropRight 1 ++ "a]"
          else
            x.1
        let z := z.modify i fun x => x.dropRight 1 ++ toBase26 (count + 1) ++ "]"
        (z, x.2.insert tag (first, count + 1))
      else
        (x.1, x.2.insert tag (i, 0))
    deduplicateTagAux y (i + 1)
  else
    x

/-- Deduplicate an array of tag. -/
def deduplicateTag' (arr : Array String) : Array String :=
  (deduplicateTagAux (arr, .empty) 0).1

/-- Deduplicate the tag of an array of bibtex entries. -/
def deduplicateTag (arr : Array ProcessedEntry) : Array ProcessedEntry :=
  Array.zip arr (deduplicateTag' <| arr.map fun x => x.tag) |>.map fun (x, s) =>
    { x with tag := s }

end BibtexQuery
