/-
Copyright (c) 2024 Jz Pan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jz Pan
-/

import BibtexQuery.Name
import BibtexQuery.Entry
import Lean.Data.Xml.Basic
import Lean.Data.HashMap
import Std.Internal.Parsec
import Std.Internal.Parsec.String

/-!

# Bibtex item formatting

This file contains functions for bibtex item formatting,
tag generating and sorting.

-/

open Lean Xml Std.Internal.Parsec Unicode BibtexQuery.TexDiacritics BibtexQuery.Name

namespace BibtexQuery

/-- Represents a processed bibtex entry. -/
structure ProcessedEntry where
  /-- The category of a bibtex entry, e.g. "article" or "book". -/
  category : String
  /-- The name, or called citekey, of a bibtex entry. -/
  name : String
  /-- The tags of a bibtex entry, stored as a `HashMap`. Don't be confused with `tag`. -/
  tags : HashMap String String
  /-- The tag of a bibtex entry, e.g. `[Doe12]`. Don't be confused with `tags`. -/
  tag : String
  /-- The HTML representing a bibtex entry, e.g.
  `John Doe. <i>Test</i>. 2012.` Generated by bibtex formatter. -/
  html : Array Content
  /-- The array of authors or editors of a bibtex entry.
  Only used for tag generation and bibtex entry sorting. -/
  authorOrEditor : Array BibtexName
  /-- The string representing the authors, generated by `authorsToString`. -/
  authorStr : String
  /-- The string representing the editors, generated by `authorsToString`. -/
  editorStr : String
  /-- The date of a bibtex entry, in the format `year * 100 + month`.
  Only used for tag generation and bibtex entry sorting. -/
  date : Nat
  /-- The string representing the date. -/
  dateStr : String
  /-- The title of a bibtex entry, with diacritics removed, and converted to uppercase.
  Only used for bibtex entry sorting. -/
  titleWithoutDiacritics : String

partial def removeDuplicatedSpacesAux (s : String) : String :=
  let s2 := s.replace "  " " "
  if s2.length < s.length then
    removeDuplicatedSpacesAux s2
  else
    s

def removeDuplicatedSpaces (s : String) : String :=
  s.replace "\r" " " |>.replace "\n" " " |>.replace "\t" " " |>.trim |> removeDuplicatedSpacesAux

/-- Convert the array of authors to string, separating with ", ", without the trailing ".". -/
def authorsToString (authors : Array BibtexName) : String :=
  let arr := authors.map (fun x =>
    (x.firstName ++ " " ++ x.lastName).trim) |>.filter (not ·.isEmpty)
  ", ".intercalate arr.toList

/-- Get the date (which is `year * 100 + month`) and the date string of a bibitem. -/
def getDate (tags : HashMap String String) : Nat × String :=
  if let .some yearStr := tags.find? "year" then
    let yearStr := yearStr.trim
    if let .some year := yearStr.toList.filter Char.isDigit |> String.mk |>.toNat? then
      let month : Nat :=
        if let .some monthStr := tags.find? "month" then
          let monthStr := monthStr.trim.toLower
          match monthStr with
          | "jan" => 1 | "feb" => 2 | "mar" => 3
          | "apr" => 4 | "may" => 5 | "jun" => 6
          | "jul" => 7 | "aug" => 8 | "sep" => 9
          | "oct" => 10 | "nov" => 11 | "dec" => 12
          | _ =>
            let month := monthStr.toNat?.getD 0
            if month ≥ 1 ∧ month ≤ 12 then month else 0
        else
          0
      let monthStr : String :=
        match month with
        | 1 => "Jan" | 2 => "Feb" | 3 => "Mar"
        | 4 => "Apr" | 5 => "May" | 6 => "Jun"
        | 7 => "Jul" | 8 => "Aug" | 9 => "Sep"
        | 10 => "Oct" | 11 => "Nov" | 12 => "Dec"
        | _ => ""
      (year * 100 + month, (monthStr ++ " " ++ yearStr).trim)
    else
      (0, yearStr)
  else
    (0, "")

/-- Get the tag of a bibitem (e.g. `[ABC12]`) from authors and date. -/
def getTag (authors : Array BibtexName) (date : Nat) : String :=
  let authorString :=
    if authors.size ≥ 5 then
      (authors.toSubarray.take 3 |>.toArray.map (·.oneLetterAbbr) |>.toList |> String.join) ++ "+"
    else if authors.size ≥ 2 then
      authors.map (·.oneLetterAbbr) |>.toList |> String.join
    else
      authors.map (·.threeLetterAbbr) |>.toList |> String.join
  let dateString := if date > 0 then (toString (date / 100 + 100)).takeRight 2 else ""
  "[" ++ authorString ++ dateString ++ "]"

/-- Get a `ProcessedEntry` from an `Entry`, computes all its field except for `html`.
If the input is not `BibtexQuery.Entry.normalType`, returns `Option.none`. -/
def ProcessedEntry.ofEntry (e : Entry) : Except String (Option ProcessedEntry) := do
  match e with
  | .normalType category name tags =>
    let lst : List (String × String) ← tags.mapM fun x => do
      match x.name with
      | "author" | "editor" => pure (x.name, removeDuplicatedSpaces x.content)
      | _ =>
        match texDiacritics x.content.iter with
        | .success _ s =>
          match removeBraces s.iter with
          | .success _ s => pure (x.name, removeDuplicatedSpaces s)
          | .error it err => .error s!"failed to run removeBraces on '{it.1}' at pos {it.2}: {err}"
        | .error it err => .error s!"failed to run texDiacritics on '{it.1}' at pos {it.2}: {err}"
    let tags := HashMap.ofList lst
    let authors ← processNames (tags.findD "author" "")
    let editors ← processNames (tags.findD "editor" "")
    let authorOrEditor := if authors.isEmpty then editors else authors
    let (date, dateStr) := getDate tags
    pure <| .some {
      category := category
      name := name
      tags := tags
      tag := getTag authorOrEditor date
      html := #[]
      authorOrEditor := authorOrEditor
      authorStr := authorsToString authors
      editorStr := authorsToString editors ++
        if editors.size ≥ 2 then
          ", editors"
        else if editors.size = 1 then
          ", editor"
        else
          ""
      date := date
      dateStr := dateStr
      titleWithoutDiacritics := stripDiacriticsFromString (tags.findD "title" "") |>.map getUpperChar
    }
  | _ => pure .none

/-!

## Formatting a bibtex item

The following code is a port of `pybtex/style/formatting/unsrt.py` of `pybtex`,
originally licensed under MIT license.

-/

section

mutual

partial def getLastCharOfContent (x : Content) : Option Char :=
  match x with
  | .Element ⟨ _, _, arr ⟩ => getLastCharOfArrayContent arr
  | .Comment _ => .none
  | .Character s => if s.isEmpty then .none else .some s.back

partial def getLastCharOfArrayContent (arr : Array Content)
    (i : Nat := arr.size - 1) : Option Char :=
  if let .some x := arr.get? i then
    if let .some c := getLastCharOfContent x then
      .some c
    else if i > 0 then
      getLastCharOfArrayContent arr (i - 1)
    else
      .none
  else
    .none

end

variable (e : ProcessedEntry)

namespace Formatter

def mkTag (name content : String) : Content :=
  .Element ⟨ name, RBMap.empty, #[.Character content] ⟩

def mkTag' (name content : String) : Array Content :=
  if content.isEmpty then #[] else #[mkTag name content]

def mkHref (href content : String) : Content :=
  .Element ⟨ "a", RBMap.empty.insert "href" href, #[.Character content] ⟩

def mkHref' (href content : String) : Array Content :=
  if content.isEmpty then #[] else #[mkHref href content]

def mkStr (s : String) (pre suf : String := "") : Array Content :=
  if s.isEmpty then #[] else #[.Character (pre ++ s ++ suf)]

def mkStr' (s : String) (pre suf : String := "") : Option (Array Content) :=
  if s.isEmpty then .none else .some #[.Character (pre ++ s ++ suf)]

def arrayConcat {α} (arr : Array (Option (Array α))) (sep : Array α := #[]) : Array α :=
  arr.filterMap id |>.foldl (fun acc a =>
    acc ++ (if acc.isEmpty || a.isEmpty then #[] else sep) ++ a) #[]

def words (arr : Array (Option (Array Content))) : Option (Array Content) :=
  let arr := arrayConcat arr #[.Character " "]
  if arr.isEmpty then .none else .some arr

def sentence1 (arr : Array Content) : Option (Array Content) :=
  if arr.isEmpty then
    .none
  else if GeneralCategory.isPunctuation (getLastCharOfArrayContent arr |>.getD default) then
    .some arr
  else
    .some (arr ++ #[.Character "."])

def sentence (arr : Array (Option (Array Content))) : Option (Array Content) :=
  sentence1 <| arrayConcat arr #[.Character ", "]

def sentence' (s : String) : Array Content :=
  if s.isEmpty then
    #[]
  else if GeneralCategory.isPunctuation s.back then
    #[.Character s]
  else
    #[.Character (s ++ ".")]

def toplevel (arr : Array (Option (Array Content))) : Array Content :=
  arrayConcat arr #[.Character "\n"]

def formatVolumeAndPages : Option (Array Content) := do
  let pages ← e.tags.find? "pages"
  match e.tags.find? "volume" with
  | .some volume =>
    arrayConcat #[
      mkStr' volume,
      (mkStr · "(" ")") <$> e.tags.find? "number",
      mkStr' pages ":"
    ]
  | .none => mkStr' pages "pages "

def formatWebRefs : Option (Array Content) :=
  let formatUrl : Option (Array Content) := do
    let s ← e.tags.find? "url"
    pure <| if s.isEmpty then #[] else #[.Character "URL: ", mkHref s s]
  let formatUrl' (tagName urlPrefix namePrefix : String) : Option (Array Content) := do
    let s ← e.tags.find? tagName
    pure <| mkHref' (urlPrefix ++ s) (namePrefix ++ s)
  sentence #[
    formatUrl' "pubmed" "https://www.ncbi.nlm.nih.gov/pubmed/" "PMID:",
    formatUrl' "doi" "https://doi.org/" "doi:",
    formatUrl' "eprint" "https://arxiv.org/abs/" "arXiv:",
    formatUrl
  ]

def formatAuthorOrEditor : Option (Array Content) :=
  sentence' (if e.authorStr.isEmpty then e.editorStr else e.authorStr)

def formatVolumeAndSeries (asSentence : Bool) : Option (Array Content) :=
  let series := e.tags.find? "series"
  let arr : Array Content :=
    if let .some volume := e.tags.find? "volume" then
      arrayConcat #[
        mkStr' volume (if asSentence then "Volume " else "volume "),
        (mkStr · " of ") <$> series
      ]
    else if let .some number := e.tags.find? "number" then
      arrayConcat #[
        mkStr' number (if asSentence then "Number " else "number "),
        (mkStr · " in ") <$> series
      ]
    else
      (mkStr <$> series).getD #[]
  if asSentence then
    sentence1 arr
  else
    if arr.isEmpty then .none else .some arr

def formatChapterAndPages : Option (Array Content) :=
  let arr : Array Content :=
    arrayConcat #[
      (mkStr · "chapter ") <$> e.tags.find? "chapter",
      (mkStr · "pages ") <$> e.tags.find? "pages"
    ] #[.Character ", "]
  if arr.isEmpty then .none else .some arr

def formatEdition : Option (Array Content) :=
  (mkStr · "" " edition") <$> e.tags.find? "edition"

def formatAddressOrganizationPublisherDate (includeOrganization : Bool) :
    Option (Array Content) :=
  let organization : Option (Array Content) :=
    if includeOrganization then
      mkStr <$> e.tags.find? "organization"
    else
      .none
  if let .some address := e.tags.find? "address" then
    words #[
      sentence #[
        mkStr' address,
        mkStr' e.dateStr
      ],
      sentence #[
        organization,
        mkStr <$> e.tags.find? "publisher"
      ]
    ]
  else
    sentence #[
      organization,
      mkStr <$> e.tags.find? "publisher",
      mkStr' e.dateStr
    ]

def formatISBN : Option (Array Content) :=
  (sentence' <| "ISBN " ++ ·) <$> e.tags.find? "isbn"

/-!

### Templates

-/

def formatArticle : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    sentence #[
      mkTag' "i" <$> e.tags.find? "journal",
      formatVolumeAndPages e,
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatBook : Array Content :=
  toplevel #[
    formatAuthorOrEditor e,
    sentence #[mkTag' "i" <$> e.tags.find? "title"],
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags.find? "publisher",
      mkStr <$> e.tags.find? "address",
      formatEdition e,
      mkStr' e.dateStr
    ],
    formatISBN e,
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatBooklet : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags.find? "howpublished",
      mkStr <$> e.tags.find? "address",
      mkStr' e.dateStr,
      mkStr <$> e.tags.find? "note"
    ],
    formatWebRefs e
  ]

def formatInBook : Array Content :=
  toplevel #[
    formatAuthorOrEditor e,
    sentence #[
      mkTag' "i" <$> e.tags.find? "title",
      formatChapterAndPages e
    ],
    formatVolumeAndSeries e true,
    sentence #[
      mkStr <$> e.tags.find? "publisher",
      mkStr <$> e.tags.find? "address",
      formatEdition e,
      mkStr' e.dateStr,
      mkStr <$> e.tags.find? "note"
    ],
    formatWebRefs e
  ]

def formatInCollection : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    (fun x => #[.Character "In "] ++ x) <$> sentence #[
      mkStr' e.editorStr,
      mkTag' "i" <$> e.tags.find? "booktitle",
      formatVolumeAndSeries e false,
      formatChapterAndPages e
    ],
    sentence #[
      mkStr <$> e.tags.find? "publisher",
      mkStr <$> e.tags.find? "address",
      formatEdition e,
      mkStr' e.dateStr
    ],
    formatWebRefs e
  ]

def formatInProceedings : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    (fun x => #[.Character "In "] ++ x) <$> words #[
      sentence #[
        mkStr' e.editorStr,
        mkTag' "i" <$> e.tags.find? "booktitle",
        formatVolumeAndSeries e false,
        mkStr <$> e.tags.find? "pages"
      ],
      formatAddressOrganizationPublisherDate e true
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatManual : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence #[mkTag' "i" <$> e.tags.find? "title"],
    sentence #[
      mkStr <$> e.tags.find? "organization",
      mkStr <$> e.tags.find? "address",
      formatEdition e,
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatMasterThesis : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    sentence #[
      mkStr' "Master's thesis",
      mkStr <$> e.tags.find? "school",
      mkStr <$> e.tags.find? "address",
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatMisc : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    sentence #[
      mkStr <$> e.tags.find? "howpublished",
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatPhDThesis : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence #[mkTag' "i" <$> e.tags.find? "title"],
    sentence #[
      (mkStr <$> e.tags.find? "type") <|> mkStr' "PhD thesis",
      mkStr <$> e.tags.find? "school",
      mkStr <$> e.tags.find? "address",
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatProceedings : Array Content :=
  let arr : Array (Option (Array Content)) :=
    if e.editorStr.isEmpty then
      #[
        sentence' <$> e.tags.find? "organization",
        sentence #[
          mkTag' "i" <$> e.tags.find? "title",
          formatVolumeAndSeries e false,
          formatAddressOrganizationPublisherDate e false
        ]
      ]
    else
      #[
        sentence' e.editorStr,
        sentence #[
          mkTag' "i" <$> e.tags.find? "title",
          formatVolumeAndSeries e false,
          formatAddressOrganizationPublisherDate e true
        ]
      ]
  toplevel <| arr ++ #[
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatTechReport : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    sentence #[
      words #[
        (mkStr <$> e.tags.find? "type") <|> mkStr' "Technical Report",
        mkStr <$> e.tags.find? "number"
      ],
      mkStr <$> e.tags.find? "institution",
      mkStr <$> e.tags.find? "address",
      mkStr' e.dateStr
    ],
    sentence' <$> e.tags.find? "note",
    formatWebRefs e
  ]

def formatUnpublished : Array Content :=
  toplevel #[
    sentence' e.authorStr,
    sentence' <$> e.tags.find? "title",
    sentence #[
      mkStr <$> e.tags.find? "note",
      mkStr' e.dateStr
    ],
    formatWebRefs e
  ]

def format : Array Content :=
  match e.category with
  | "article" => formatArticle e
  | "book" => formatBook e
  | "booklet" => formatBooklet e
  | "inbook" => formatInBook e
  | "incollection" => formatInCollection e
  | "inproceedings" | "conference" => formatInProceedings e
  | "manual" => formatManual e
  | "mastersthesis" => formatMasterThesis e
  | "misc" | "online" => formatMisc e
  | "phdthesis" => formatPhDThesis e
  | "proceedings" => formatProceedings e
  | "techreport" => formatTechReport e
  | "unpublished" => formatUnpublished e
  | _ => #[.Character ("TODO: " ++ e.category)]

end Formatter

/-- Fill the `html` field of `ProcessedEntry`. -/
def ProcessedEntry.format : ProcessedEntry :=
  { e with html := Formatter.format e }

end

/-!

## Sorting bibtex items

-/

def compareAuthor (a b : BibtexName) : Ordering :=
  if a.lastNameWithoutDiacritics < b.lastNameWithoutDiacritics then
    .lt
  else if a.lastNameWithoutDiacritics > b.lastNameWithoutDiacritics then
    .gt
  else if a.firstNameWithoutDiacritics < b.firstNameWithoutDiacritics then
    .lt
  else if a.firstNameWithoutDiacritics > b.firstNameWithoutDiacritics then
    .gt
  else
    .eq

partial def compareAuthors (a b : Array BibtexName) (i : Nat := 0) : Ordering :=
  if ha : i < a.size then
    if hb : i < b.size then
      match compareAuthor a[i] b[i] with
      | .lt => .lt | .gt => .gt
      | .eq => compareAuthors a b (i + 1)
    else
      .gt
  else
    if i < b.size then .lt else .eq

def compareEntry (a b : ProcessedEntry) : Ordering :=
  match compareAuthors a.authorOrEditor b.authorOrEditor with
  | .lt => .lt | .gt => .gt
  | .eq =>
    if a.date < b.date then
      .lt
    else if a.date > b.date then
      .gt
    else if a.titleWithoutDiacritics < b.titleWithoutDiacritics then
      .lt
    else if a.titleWithoutDiacritics > b.titleWithoutDiacritics then
      .gt
    else
      .eq

/-- Sort an array of bibtex entries. -/
def sortEntry (arr : Array ProcessedEntry) : Array ProcessedEntry :=
  arr.qsort (compareEntry · · |>.isLT)

partial def toBase26Aux (n : Nat) (length : Nat) (s : String) : String :=
  if length = 0 then
    s
  else
    toBase26Aux (n / 26) (length - 1) <| toString (Char.ofNat (97 + n % 26)) ++ s

partial def toBase26 (n : Nat) (length : Nat := 1) : String :=
  if n ≥ 26 ^ length then
    toBase26 (n - 26 ^ length) (length + 1)
  else
    toBase26Aux n length ""

partial def deduplicateTagAux
    (x : Array String × HashMap String (Nat × Nat)) (i : Nat) :
    Array String × HashMap String (Nat × Nat) :=
  if h : i < x.1.size then
    let tag := x.1[i]
    let y : Array String × HashMap String (Nat × Nat) :=
      if let .some (first, count) := x.2.find? tag then
        let z : Array String :=
          if count = 0 then
            x.1.modify first fun x => x.dropRight 1 ++ "a]"
          else
            x.1
        let z := z.modify i fun x => x.dropRight 1 ++ toBase26 (count + 1) ++ "]"
        (z, x.2.insert tag (first, count + 1))
      else
        (x.1, x.2.insert tag (i, 0))
    deduplicateTagAux y (i + 1)
  else
    x

/-- Deduplicate an array of tag. -/
def deduplicateTag' (arr : Array String) : Array String :=
  (deduplicateTagAux (arr, .empty) 0).1

/-- Deduplicate the tag of an array of bibtex entries. -/
def deduplicateTag (arr : Array ProcessedEntry) : Array ProcessedEntry :=
  Array.zip arr (deduplicateTag' <| arr.map fun x => x.tag) |>.map fun (x, s) =>
    { x with tag := s }

end BibtexQuery
